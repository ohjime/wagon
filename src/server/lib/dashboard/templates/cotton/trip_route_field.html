{% comment %}
Address Route widget (Cotton component)
Usage:
<c-address-route api-key="YOUR_GOOGLE_MAPS_KEY" initial-origin="123 Main St, City" initial-destination="456 Oak Ave, City" initial-origin-id="ChIJ..." initial-destination-id="ChIJ..." />
- DaisyUI for styles
- Alpine.js for interactivity
- Google Maps JS API (Places + Directions) loaded on demand using api-key attr
{% endcomment %}
<div class="w-full max-w-4xl mx-auto"
     data-api-key="{{ api_key|default_if_none:'' }}"
     data-initial-origin="{{ initial_origin|default:'' }}"
     data-initial-destination="{{ initial_destination|default:'' }}"
     data-initial-origin-id="{{ initial_origin_id|default:'' }}"
     data-initial-destination-id="{{ initial_destination_id|default:'' }}"
     x-data="addressRoute()"
     x-init="ensureMapsLoaded($root)"
     x-cloak>
    <style>
        [x-cloak] {
            display: none !important;
        }
    </style>
    <fieldset class="fieldset w-full rounded-box border border-base-300 bg-base-100 !p-4">
        <legend class="fieldset-legend text-lg">
            Trip Route
        </legend>
        <div class="w-full flex flex-row">
            <!-- Inputs -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full">
                <!-- Origin -->
                <div class="relative">
                    <label class="label">
                        <span class="label-text">Origin</span>
                    </label>
                    <label class="input input-bordered flex items-center gap-2">
                        <svg class="h-[1em] opacity-50"
                             xmlns="http://www.w3.org/2000/svg"
                             viewBox="0 0 24 24">
                            <g stroke-linejoin="round" stroke-linecap="round" stroke-width="2.5" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.3-4.3">
                            </path>
                            </g>
                        </svg>
                        <input type="text"
                               placeholder="Start address..."
                               class="grow"
                               x-model="originText"
                               @input.debounce.300ms="fetchPredictions('origin')"
                               @focus="showOrigin = originPreds.length > 0" />
                    </label>
                    <!-- Suggestions -->
                    <ul x-show="showOrigin"
                        @click.outside="showOrigin=false"
                        class="menu bg-base-100 rounded-box shadow-lg absolute w-full z-20 mt-2 border border-base-300">
                        <template x-for="pred in originPreds"
                                  :key="pred.place_id">
                            <li>
                                <a class="whitespace-normal"
                                   @click.prevent="selectPrediction('origin', pred)"
                                   x-text="pred.description"></a>
                            </li>
                        </template>
                        <li x-show="originPreds.length === 0"
                            class="p-2 text-sm opacity-60">
                            No suggestions
                        </li>
                    </ul>
                </div>
                <!-- Destination -->
                <div class="relative">
                    <label class="label">
                        <span class="label-text">Destination</span>
                    </label>
                    <label class="input input-bordered flex items-center gap-2">
                        <svg class="h-[1em] opacity-50"
                             xmlns="http://www.w3.org/2000/svg"
                             viewBox="0 0 24 24">
                            <g stroke-linejoin="round" stroke-linecap="round" stroke-width="2.5" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.3-4.3">
                            </path>
                            </g>
                        </svg>
                        <input type="text"
                               placeholder="End address..."
                               class="grow"
                               x-model="destinationText"
                               @input.debounce.300ms="fetchPredictions('destination')"
                               @focus="showDestination = destinationPreds.length > 0" />
                    </label>
                    <!-- Suggestions -->
                    <ul x-show="showDestination"
                        @click.outside="showDestination=false"
                        class="menu bg-base-100 rounded-box shadow-lg absolute w-full z-20 mt-2 border border-base-300">
                        <template x-for="pred in destinationPreds"
                                  :key="pred.place_id">
                            <li>
                                <a class="whitespace-normal"
                                   @click.prevent="selectPrediction('destination', pred)"
                                   x-text="pred.description"></a>
                            </li>
                        </template>
                        <li x-show="destinationPreds.length === 0"
                            class="p-2 text-sm opacity-60">
                            No suggestions
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        <!-- Map -->
        <div class="mt-2">
            <div id="address-map"
                 class="w-full aspect-video rounded-box border border-base-300">
            </div>
        </div>
    </fieldset>
    <script>
        function addressRoute() {
            return {
                apiKey: null,
                map: null,
                directionsService: null,
                directionsRenderer: null,
                autocompleteService: null,
                placesService: null,
                originText: '',
                destinationText: '',
                originPlaceId: '',
                destinationPlaceId: '',
                originPreds: [],
                destinationPreds: [],
                showOrigin: false,
                showDestination: false,

                ensureMapsLoaded(root) {
                    // Prefer data-api-key from component, fallback to global/window
                    this.apiKey = (root?.dataset?.apiKey || window.GOOGLE_MAPS_API_KEY || 'YOUR_API_KEY').trim();
                    // Seed initial values from attributes
                    this.originText = root?.dataset?.initialOrigin || '';
                    this.destinationText = root?.dataset?.initialDestination || '';
                    this.originPlaceId = root?.dataset?.initialOriginId || '';
                    this.destinationPlaceId = root?.dataset?.initialDestinationId || '';
                    if (window.google?.maps?.places) {
                        this.initMap();
                        return;
                    }
                    const id = 'google-maps-js';
                    const existing = document.getElementById(id);
                    if (existing) {
                        existing.addEventListener('load', () => this.initMap(), {
                            once: true
                        });
                        return;
                    }
                    const s = document.createElement('script');
                    s.id = id;
                    s.async = true;
                    s.defer = true;
                    s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(this.apiKey)}&libraries=places`;
                    s.onload = () => this.initMap();
                    document.head.appendChild(s);
                },

                async initMap() {
                    const mapEl = document.getElementById('address-map');
                    if (!mapEl) return;
                    // Import ColorScheme enum from the Maps core library
                    let ColorScheme;
                    try {
                        ({
                            ColorScheme
                        } = await google.maps.importLibrary('core'));
                    } catch (e) {
                        console.warn('Failed to import google.maps ColorScheme; falling back to default (LIGHT).', e);
                    }

                    const mapOptions = {
                        center: {
                            lat: 53.5461,
                            lng: -113.4938
                        },
                        zoom: 12,
                        mapTypeControl: false,
                        streetViewControl: false,
                        fullscreenControl: false,
                        // Apply light/dark color scheme if available
                        ...(ColorScheme ? {
                            colorScheme: this.getCurrentColorScheme(ColorScheme)
                        } : {}),
                    };

                    this.map = new google.maps.Map(mapEl, mapOptions);
                    this.directionsService = new google.maps.DirectionsService();
                    this.directionsRenderer = new google.maps.DirectionsRenderer({
                        map: this.map
                    });
                    this.autocompleteService = new google.maps.places.AutocompleteService();
                    this.placesService = new google.maps.places.PlacesService(this.map);

                    // Observe theme changes and update map color scheme accordingly
                    if (ColorScheme) this.observeThemeChanges(ColorScheme);

                    // If both are pre-seeded, draw route immediately
                    if (this.originPlaceId && this.destinationPlaceId) {
                        this.$nextTick(() => this.calculateAndDisplayRoute());
                    }
                },

                getCurrentColorScheme(ColorScheme) {
                    // Try to detect DaisyUI/Tailwind dark mode via data-theme or .dark class
                    const root = document.documentElement;
                    const theme = root?.dataset?.theme || '';
                    const isDarkClass = root?.classList?.contains('dark');
                    if (theme) {
                        return theme.toLowerCase().includes('dark') ? ColorScheme.DARK : ColorScheme.LIGHT;
                    }
                    if (isDarkClass) return ColorScheme.DARK;
                    // Fall back to following system preference when app theme is unknown
                    return ColorScheme.FOLLOW_SYSTEM ?? ColorScheme.LIGHT;
                },

                observeThemeChanges(ColorScheme) {
                    // Recreate the map when theme changes, since colorScheme is only applied at initialization
                    const recreate = () => this.recreateMapWithScheme(ColorScheme);

                    // Observe data-theme/class changes (DaisyUI/Tailwind)
                    const mo = new MutationObserver((mutations) => {
                        for (const m of mutations) {
                            if (m.type === 'attributes' && (m.attributeName === 'data-theme' || m.attributeName === 'class')) {
                                recreate();
                                break;
                            }
                        }
                    });
                    mo.observe(document.documentElement, {
                        attributes: true,
                        attributeFilter: ['data-theme', 'class']
                    });

                    // Also respond to system scheme changes if following system
                    const media = window.matchMedia('(prefers-color-scheme: dark)');
                    if (media?.addEventListener) media.addEventListener('change', recreate);
                    else if (media?.addListener) media.addListener(recreate);

                    // Store to allow potential cleanup (not strictly needed in this component lifecycle)
                    this._themeMO = mo;
                    this._themeMQL = media;
                },

                recreateMapWithScheme(ColorScheme) {
                    const mapEl = document.getElementById('address-map');
                    if (!mapEl) return;
                    const center = this.map?.getCenter?.() || {
                        lat: 53.5461,
                        lng: -113.4938
                    };
                    const zoom = this.map?.getZoom?.() || 12;

                    const options = {
                        center,
                        zoom,
                        mapTypeControl: false,
                        streetViewControl: false,
                        fullscreenControl: false,
                        colorScheme: this.getCurrentColorScheme(ColorScheme),
                    };

                    // Recreate map and re-wire services tied to the Map instance
                    this.map = new google.maps.Map(mapEl, options);
                    this.directionsRenderer = new google.maps.DirectionsRenderer({
                        map: this.map
                    });
                    this.placesService = new google.maps.places.PlacesService(this.map);

                    // Re-draw route if available
                    if (this.originPlaceId && this.destinationPlaceId) {
                        this.calculateAndDisplayRoute();
                    }
                },

                fetchPredictions(field) {
                    const text = field === 'origin' ? this.originText : this.destinationText;
                    const showKey = field === 'origin' ? 'showOrigin' : 'showDestination';
                    const listKey = field === 'origin' ? 'originPreds' : 'destinationPreds';
                    if (!text) {
                        this[listKey] = [];
                        this[showKey] = false;
                        return;
                    }
                    if (!this.autocompleteService) return;
                    this.autocompleteService.getPlacePredictions({
                        input: text
                    }, (preds, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && preds) {
                            this[listKey] = preds;
                            this[showKey] = preds.length > 0;
                        } else {
                            this[listKey] = [];
                            this[showKey] = false;
                        }
                    });
                },

                selectPrediction(field, pred) {
                    if (field === 'origin') {
                        this.originText = pred.description;
                        this.originPlaceId = pred.place_id;
                        this.showOrigin = false;
                    } else {
                        this.destinationText = pred.description;
                        this.destinationPlaceId = pred.place_id;
                        this.showDestination = false;
                    }
                    this.notifyChange();
                    if (this.originPlaceId && this.destinationPlaceId) {
                        this.calculateAndDisplayRoute();
                    }
                },

                calculateAndDisplayRoute() {
                    if (!this.originPlaceId || !this.destinationPlaceId) return;
                    this.directionsService.route({
                            origin: {
                                placeId: this.originPlaceId
                            },
                            destination: {
                                placeId: this.destinationPlaceId
                            },
                            travelMode: google.maps.TravelMode.DRIVING,
                        },
                        (response, status) => {
                            if (status === 'OK') {
                                this.directionsRenderer.setDirections(response);
                                this.notifyChange();
                            } else {
                                console.warn('Directions request failed:', status);
                            }
                        }
                    );
                },

                resetForm() {
                    this.originText = '';
                    this.destinationText = '';
                    this.originPlaceId = '';
                    this.destinationPlaceId = '';
                    this.originPreds = [];
                    this.destinationPreds = [];
                    this.showOrigin = false;
                    this.showDestination = false;
                    if (this.directionsRenderer) this.directionsRenderer.set('directions', null);
                    if (this.map) this.map.setCenter({
                        lat: 53.5461,
                        lng: -113.4938
                    });
                    if (this.map) this.map.setZoom(12);
                    this.notifyChange();
                },

                notifyChange() {
                    // Emit a custom event so parent can sync hidden form inputs
                    this.$dispatch('route-changed', {
                        origin: this.originText,
                        originPlaceId: this.originPlaceId,
                        destination: this.destinationText,
                        destinationPlaceId: this.destinationPlaceId
                    });
                }
            }
        }
    </script>
</div>
